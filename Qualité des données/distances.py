# -*- coding: utf-8 -*-
"""distances.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g0oQ-hKBzI2G-bs0yDRC5fb7cTMm7RUI
"""

import numpy as np

def distance_Levenshtein(chaine1, chaine2):
  l1 = len(chaine1)
  l2 = len(chaine2)
  d = np.zeros((l1+1,l2+1))
  cout_substitution = 0
  for i in range(l1+1):
    d[i,0]=i
  for j in range(l2+1):
    d[0,j]=j
  
  for i in range(1,l1+1):
    for j in range(1,l2+1):
      if chaine1[i-1] == chaine2[j-1]:
        cout_substitution = 0
      else :
        cout_substitution = 1
      d[i,j] = min( d[i - 1,j] + 1, d[i, j - 1] + 1, d[i - 1, j - 1] + cout_substitution)
  return int(d[l1,l2])

distance_Levenshtein('chiens','niche')

def distance_Jaro(chaine1,chaine2):
  s1 = len(chaine1)
  s2 = len(chaine2)
  eloignement_max = int(max(s1,s2)/2)-1
  c = np.zeros((s1,s2))

  for i in range(s1):
    for j in range(max(0,i-eloignement_max),min(i+eloignement_max,s2)):
      if chaine1[i] == chaine2[j]:
        c[i,j]=1
  m = np.sum(c)
  t = 0
  if s1 == s2 :

    for i in range(s1):
      if chaine1[i] != chaine2[i]:
        t+=1
    t = (t+abs(s1-s2))/2
  d = (m/s1+m/s2+(m-t)/m)/3
  return d

distance_Jaro('MARTHA','MARHTA')

def distance_Jaro_Winkler(chaine1,chaine2,p=0.1):
  dj = distance_Jaro(chaine1,chaine2)
  l = 0
  l = 0
  while (chaine1[l] == chaine2[l]) & (l<=4):
    l += 1

  return dj + (l*p*(1-dj))

distance_Jaro_Winkler('MARTHA','MARHTA')

distance_Jaro_Winkler('DWAYNE','DUANE')

distance_Jaro('DWAYNE','DUANE')

distance_Jaro('DIXON','DICKSONX')

distance_Jaro_Winkler('DIXON','DICKSONX')

def Soundex(chaine):

  #suppression espaces
  code = chaine.replace(" ","")

  #mot en majuscule
  code = chaine.upper()

  #supprimer les occurences
  occurences = ["A","E","H","I","O","U","W","Y"]
  i=1
  while i < len(code):
    if np.isin(code[i],occurences):
      code = code[:i] + code[i+1:]
    else:
      i+=1

  #attribuer une valeur numérique aux lettres restantes
  to_num_fr={'B':'1','P':'1',
       'C':'2','K':'2','Q':'2',
       'D':'3','T':'3',
       'L':'4',
       'M':'5','N':'5',
       'R':'6',
       'G':'7','J':'7',
       'X':'8','Z':'8','S':'8',
       'F':'9','V':'9'}
  for i in range(1,len(code)):
    code = code[:i] + to_num_fr[code[i]] + code[i+1:]

  #eliminer les doubles numéros
  i=1
  while i < len(code)-1:
    if code[i] == code[i+1]:
      code = code[:i] + code[i+1:]
    else:
      i+=1
  
  #completer les quatre premiers octets
  if len(code)<4:
    while len(code)!=4:
      code = code + "0"
  return code

Soundex("Hello")

print(Soundex("Robert"),Soundex("Rubin"))

def distance_Jacard(vecteur1,vecteur2):
  #vecteur1 = np.array([#,#,#])
  S_min = 0
  S_max = 0
  for i in range(len(vecteur1)):
    S_min = S_min + min(vecteur1[i],vecteur2[i])
    S_max = S_max + max(vecteur1[i],vecteur2[i])
  return 1 - S_min/S_max

X=np.array([1,0,1,0,0,0,0])
Y=np.array([1,0,0,1,0,1,1])
print(X,Y)

distance_Jacard(X,Y)

def distance_Hamming(vecteur1,vecteur2):
  #vecteur1 = np.array([#,#,#])
  H = 0
  for i in range(len(vecteur1)):
    if vecteur1[i] != vecteur2[i]:
      H += 1
  return H

distance_Hamming(X,Y)

def val_abs(v1,v2):
  return np.abs(v1-v2)